import assert from 'node:assert';
import { fileURLToPath } from 'node:url';

import { toPath } from '@-xun/fs';
import { webpackConfigProjectBase } from '@-xun/project';
import { createDebugLogger } from 'rejoinder';

import {
  AssetPreset,
  generateRootOnlyAssets,
  makeTransformer
} from 'universe:assets.ts';

import { globalDebuggerNamespace } from 'universe:constant.ts';

import type { AbsolutePath } from '@-xun/fs';

const debug = createDebugLogger({
  namespace: '${globalDebuggerNamespace}:asset:webpack'
});

export function moduleExport(): Record<string, unknown> {
  return {
    // TODO: include WebpackCustomSchemeAliasPlugin too
  };
}

export const { transformer } = makeTransformer(function (context) {
  const { asset, toProjectAbsolutePath, assetPreset } = context;

  if (assetPreset && assetPreset !== AssetPreset.Nextjs) {
    return [];
  }

  // * Only the root package gets these files
  return generateRootOnlyAssets(context, async function () {
    return [
      {
        path: toProjectAbsolutePath(webpackConfigProjectBase),
        generate: () => /*js*/ `
// @ts-check
'use strict';

import { deepMergeConfig } from '@-xun/symbiote/assets';
import { moduleExport } from '@-xun/symbiote/assets/${asset}';
import { createDebugLogger } from 'rejoinder';

const debug = createDebugLogger({ namespace: '${globalDebuggerNamespace}:config:webpack' });

/**
 * @type {import('webpack').WebpackOptionsNormalized}
 */
const baseConfig = moduleExport();
const config = deepMergeConfig(baseConfig, {
  // Any custom configs here will be deep merged with moduleExport's result
});

export default config;
debug('exported config: %O', config);
`
      }
    ];
  });
});

/**
 * This class fills in the gap when using aliases that look like protocols since
 * Webpack 5 does not properly respect `resolve.alias` when strings with
 * so-called "protocols" (e.g. `universe:api.ts` or
 * `multiverse+shared:something.ts`) are present.
 */
export class WebpackCustomSchemeAliasPlugin {
  #schemes = new Map();
  #projectRoot: string;

  constructor(
    projectRoot: AbsolutePath,
    /**
     * An object of definitions for Webpack's `resolve.alias` (or Next.js)
     * generated by `@-xun/symbiote`.
     *
     * If `resolverAliases` does not include at least one protocol-like key
     * (i.e. a string with a `:` in it), this plugin becomes a no-op.
     */
    resolverAliases: Record<string, string>
  ) {
    this.#projectRoot = projectRoot;

    Object.entries(resolverAliases).forEach(([k, v]) =>
      k.includes(':') ? this.#schemes.set(k.split(':')[0], v.split('*')[0]) : undefined
    );

    debug('project root: %O', this.#projectRoot);
    debug('registered alias schemes: %O', this.#schemes);
  }

  apply(compiler: unknown) {
    // ? This is done this way so we can keep webpack as a dev dependency
    const { NormalModule } = require('webpack'.toString()) as typeof import('webpack');

    (compiler as InstanceType<typeof import('webpack').Compiler>).hooks.compilation.tap(
      WebpackCustomSchemeAliasPlugin.name,
      (compilation, { normalModuleFactory }) => {
        NormalModule.getCompilationHooks(compilation).readResourceForScheme.intercept({
          factory: (scheme: unknown, hook) => {
            const schemePath = this.#schemes.get(scheme);

            assert(typeof scheme === 'string', `non-string scheme "${String(scheme)}"`);
            assert(hook, 'undefined hook for scheme ' + scheme);

            const localDebug = debug.extend('read:' + scheme);

            if (schemePath !== undefined) {
              hook.tap(
                WebpackCustomSchemeAliasPlugin.name,
                (resource, { resourceResolveData }) => {
                  localDebug(
                    'returning content (~%O bytes) for resource: %O',
                    resource.length,
                    resourceResolveData
                  );

                  return resource;
                }
              );

              debug(
                'tapped NormalModule.hooks.readResourceForScheme for %O (%O)',
                scheme,
                schemePath
              );
            } else {
              debug.message(
                'skipped tapping NormalModule.hooks.readResourceForScheme for %O (%O)',
                scheme,
                schemePath
              );
            }

            return hook;
          }
        });

        normalModuleFactory.hooks.resolveForScheme.intercept({
          factory: (scheme: unknown, hook) => {
            const schemePath = this.#schemes.get(scheme);

            assert(typeof scheme === 'string', `non-string scheme "${String(scheme)}"`);
            assert(hook, 'undefined hook for scheme ' + scheme);

            const localDebug = debug.extend('resolve:' + scheme);

            if (schemePath !== undefined) {
              // * https://github.com/webpack/webpack/blob/ad1e3b46f46b9acd5bb9c377afcdc101338d5c96/lib/schemes/FileUriPlugin.js
              hook.tap(WebpackCustomSchemeAliasPlugin.name, (resourceData) => {
                localDebug('encountered resource data: %O', resourceData);

                const url = new URL(
                  resourceData.resource.replace(`${scheme}:`, 'file:')
                );

                const path = toPath(this.#projectRoot, schemePath, fileURLToPath(url));
                const query = url.search;
                const fragment = url.hash;

                resourceData.path = path;
                resourceData.query = query;
                resourceData.fragment = fragment;
                resourceData.resource = path + query + fragment;

                localDebug('updated resource data: %O', resourceData);

                return true;
              });

              debug(
                'tapped normalModuleFactory.hooks.resolveForScheme for %O (%O)',
                scheme,
                schemePath
              );
            } else {
              debug.message(
                'skipped tapping normalModuleFactory.hooks.resolveForScheme for %O (%O)',
                scheme,
                schemePath
              );
            }

            return hook;
          }
        });
      }
    );

    debug('tapped compiler.hooks.compilation');
  }
}
