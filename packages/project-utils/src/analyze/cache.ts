import { createHash } from 'node:crypto';

import {
  debug as debug_,
  type Package,
  type PackageBuildTargets,
  type PackageFiles,
  type ProjectFiles,
  type ProjectMetadata
} from '#project-utils src/analyze/common.ts';

import { type AbsolutePath } from '#project-utils src/fs.ts';

/**
 * A key used to cache resources. Generated by {@link deriveCacheKeyFromPackageAndData}.
 */
export type CacheKey = string;

export const cacheDebug = debug_.extend('cache');

/**
 * A mapping between project root paths and {@link ProjectMetadata} instances.
 */
export const _internalProjectMetadataCache = new Map<AbsolutePath, ProjectMetadata>();

/**
 * A mapping between {@link ProjectMetadata} instances and {@link ProjectFiles}
 * instances.
 */
export const _internalProjectFilesCache = new Map<CacheKey, ProjectFiles>();

/**
 * A mapping between {@link Package} instances and {@link PackageBuildTargets}
 * instances.
 */
export const _internalPackageBuildTargetsCache = new Map<CacheKey, PackageBuildTargets>();

/**
 * A mapping between {@link Package} instances and {@link AbsolutePath} array
 * instances.
 */
export const _internalPackageFilesCache = new Map<CacheKey, PackageFiles>();

/**
 * Clear one or more internal caches. Mostly useful in a testing context.
 */
export function clearInternalCache({
  gatherProjectFiles = true,
  gatherPackageFiles = true,
  gatherPackageBuildTargets = true,
  analyzeProjectStructure = true
}: {
  gatherProjectFiles?: boolean;
  gatherPackageFiles?: boolean;
  gatherPackageBuildTargets?: boolean;
  analyzeProjectStructure?: boolean;
} = {}) {
  if (gatherProjectFiles) {
    cacheDebug('internal gatherProjectFiles cache cleared');
    _internalProjectFilesCache.clear();
  }

  if (gatherPackageFiles) {
    cacheDebug('internal gatherPackageFiles cache cleared');
    _internalPackageFilesCache.clear();
  }

  if (gatherPackageBuildTargets) {
    cacheDebug('internal gatherPackageBuildTargets cache cleared');
    _internalPackageBuildTargetsCache.clear();
  }

  if (analyzeProjectStructure) {
    cacheDebug('internal analyzeProjectStructure cache cleared');
    _internalProjectMetadataCache.clear();
  }
}

/**
 * Takes a {@link Package} and a data object, _which must be serializable as
 * JSON_, and deterministically returns a MD5 key that can be used to memoize
 * our more expensive analysis functions.
 */
export function deriveCacheKeyFromPackageAndData(
  { projectMetadata: _, ...package_ }: Package,
  data: Record<string, unknown>
): CacheKey {
  const cacheKey = createHash('md5')
    .update(JSON.stringify(package_))
    .update(JSON.stringify(data))
    .digest('hex');

  cacheDebug('cache key: %O', cacheKey);
  return cacheKey;
}
