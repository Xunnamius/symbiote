import { createHash } from 'node:crypto';

import {
  debug as debug_,
  type Package,
  type PackageBuildTargets,
  type PackageFiles,
  type ProjectFiles,
  type ProjectMetadata
} from '#project-utils src/analyze/common.ts';

import { type Pseudodecorator } from '#project-utils src/analyze/gather-pseudodecorator-entries-from-files.ts';

import { type AbsolutePath } from '#project-utils src/fs.ts';

/**
 * A key used to cache resources. Generated by {@link deriveCacheKeyFromPackageAndData}.
 */
export type CacheKey = string;

export const cacheDebug = debug_.extend('cache');

/**
 * A mapping between project root paths and {@link ProjectMetadata} instances.
 */
export const _internalProjectMetadataCache = new Map<AbsolutePath, ProjectMetadata>();

/**
 * A mapping between absolute paths and {@link Pseudodecorator} instance arrays.
 */
export const _internalPseudodecoratorCache = new Map<AbsolutePath, Pseudodecorator[]>();

/**
 * A mapping between {@link ProjectMetadata} instances and {@link ProjectFiles}
 * instances.
 */
export const _internalProjectFilesCache = new Map<CacheKey, ProjectFiles>();

/**
 * A mapping between {@link Package} instances and {@link PackageBuildTargets}
 * instances.
 */
export const _internalPackageBuildTargetsCache = new Map<CacheKey, PackageBuildTargets>();

/**
 * A mapping between {@link Package} instances and {@link AbsolutePath} array
 * instances.
 */
export const _internalPackageFilesCache = new Map<CacheKey, PackageFiles>();

/**
 * Clear one or more internal caches. Mostly useful in a testing context.
 */
export function clearInternalCache({
  gatherProjectFiles = true,
  gatherPackageFiles = true,
  gatherPackageBuildTargets = true,
  gatherPseudodecoratorsEntriesFromFiles = true,
  analyzeProjectStructure = true
}: {
  gatherProjectFiles?: boolean;
  gatherPackageFiles?: boolean;
  gatherPackageBuildTargets?: boolean;
  gatherPseudodecoratorsEntriesFromFiles?: boolean;
  analyzeProjectStructure?: boolean;
} = {}) {
  if (gatherProjectFiles) {
    cacheDebug(
      'internal gatherProjectFiles cache cleared (%O entries deleted)',
      _internalProjectFilesCache.size
    );
    _internalProjectFilesCache.clear();
  }

  if (gatherPackageFiles) {
    cacheDebug(
      'internal gatherPackageFiles cache cleared (%O entries deleted)',
      _internalPackageFilesCache.size
    );
    _internalPackageFilesCache.clear();
  }

  if (gatherPackageBuildTargets) {
    cacheDebug(
      'internal gatherPackageBuildTargets cache cleared (%O entries deleted)',
      _internalPackageBuildTargetsCache.size
    );
    _internalPackageBuildTargetsCache.clear();
  }

  if (gatherPseudodecoratorsEntriesFromFiles) {
    cacheDebug(
      'internal gatherPseudodecoratorsEntriesFromFiles cache cleared (%O entries deleted)',
      _internalPseudodecoratorCache.size
    );
    _internalPseudodecoratorCache.clear();
  }

  if (analyzeProjectStructure) {
    cacheDebug(
      'internal analyzeProjectStructure cache cleared (%O entries deleted)',
      _internalProjectMetadataCache.size
    );
    _internalProjectMetadataCache.clear();
  }
}

/**
 * Takes a {@link Package} and a data object, _which must be serializable as
 * JSON_, and deterministically returns a MD5 key that can be used to memoize
 * our more expensive analysis functions.
 */
export function deriveCacheKeyFromPackageAndData(
  { projectMetadata: _, ...package_ }: Package,
  data: Record<string, unknown>
): CacheKey {
  const cacheKey = createHash('md5')
    .update(JSON.stringify(package_))
    .update(JSON.stringify(data))
    .digest('hex');

  cacheDebug('derived cache key: %O', cacheKey);
  return cacheKey;
}
